import * as utils from "../../AdventOfCodeUtils";

/** Day 24 Solution */
export function solution(rawInput: string[]): utils.Solution {
	const nodeVals: utils.StringKeyedObject<number> = {};
	const ops: string[][] = [];
	const outputs: utils.StringKeyedObject<Output> = {};

	for (const line of rawInput) {
		const valMatch = line.match(/^(.*): (.*)$/);
		if (valMatch) {
			nodeVals[valMatch[1]] = +valMatch[2];
		}
		const opMatch = line.match(/^(.*) (.*) (.*) -> (.*)$/);
		if (opMatch) {
			const op = opMatch.slice(1, 5);
			ops.push(op);
			outputs[op[3]] = {
				operands: [op[0], op[2]],
				operator: op[1] as Operator,
			};
		}
	}

	while (ops.length) {
		for (let ix = 0; ix < ops.length; ix++) {
			const op = ops[ix];
			if (nodeVals[op[0]] === undefined || nodeVals[op[2]] === undefined) { continue; }
			switch (op[1]) {
				case "AND": nodeVals[op[3]] = nodeVals[op[0]] & nodeVals[op[2]]; break;
				case "OR": nodeVals[op[3]] = nodeVals[op[0]] | nodeVals[op[2]]; break;
				case "XOR": nodeVals[op[3]] = nodeVals[op[0]] ^ nodeVals[op[2]]; break;
			}
			ops.splice(ix--, 1);
		}
	}

	let sum = 0;
	let biggestZ = 0;
	for (const node in nodeVals) {
		const zMatch = node.match(/z\d\d/);
		if (!zMatch) { continue; }
		const exponent = +zMatch[0].replace("z", "");
		sum += nodeVals[node] * 2 ** exponent;
		biggestZ = Math.max(biggestZ, exponent);
	}

	const badOuts: string[] = [];
	for (const output in outputs) {
		const { operands, operator } = outputs[output];
		if (output.match(/z\d\d/)) {

			// The output digits (prefixed z) should always be the result of an XOR operation (excluding last bit)
			if (operator !== "XOR") {
				if (!output.includes(biggestZ.toString())) {
					badOuts.push(output);
				}
				continue;
			}

			for (const operand of operands) {
				const precursor = outputs[operand];
				
				// Evaluating base bit; below cases don't apply
				if (!precursor) { continue; }

				// One of the two operands to a z-generating XOR operator must be a XOR of its corresponding x and y
				if (precursor.operator === "XOR" && !precursor.operands[0].match(/^(x|y)/)) {
					badOuts.push(operand);
				}

				// Excluding initial carry bit, no operand for a z-generating XOR should come from an AND operation
				if (precursor.operator === "AND" && !precursor.operands[0].includes("00")) {
					badOuts.push(operand);
				}
			}
		} 
		// OR operation only occurs to consolidate carry-over bits (both results of AND operations): (X&Y) | (C&(X^Y))
		// Verify both operands are generated by ANDs.
		if (operator === "OR") {
			for (const operand of operands) {
				const precursor = outputs[operand];
				if (precursor.operator !== "AND") { badOuts.push(operand); }
			}
		}
	}
	
	return [sum, badOuts.sort().join(",")];
}

interface Output {
	operator: Operator;
	operands: string[];
}

type Operator = "AND" | "OR" | "XOR";